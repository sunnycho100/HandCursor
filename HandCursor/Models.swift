//
//  Models.swift
//  HandCursor
//
//  Core data structures for hand tracking and gesture recognition
//

import Foundation
import CoreGraphics

// MARK: - Hand Landmark

/// Represents a single hand landmark point in normalized coordinates (0.0-1.0)
struct HandLandmark {
    let id: String
    let x: CGFloat
    let y: CGFloat
    let confidence: Float
    
    init(id: String, x: CGFloat, y: CGFloat, confidence: Float = 1.0) {
        self.id = id
        self.x = x
        self.y = y
        self.confidence = confidence
    }
    
    var point: CGPoint {
        CGPoint(x: x, y: y)
    }
}

// MARK: - Hand Frame

/// Represents a complete hand detection frame with all landmarks
struct HandFrame {
    let timestamp: CFTimeInterval
    let landmarks: [HandLandmark]
    let confidence: Float
    
    /// Key landmark accessors
    var thumbTip: HandLandmark? {
        landmarks.first { $0.id == "thumbTip" }
    }
    
    var indexTip: HandLandmark? {
        landmarks.first { $0.id == "indexTip" }
    }
    
    /// Calculate distance between two landmarks
    func distance(from: String, to: String) -> CGFloat? {
        guard let landmark1 = landmarks.first(where: { $0.id == from }),
              let landmark2 = landmarks.first(where: { $0.id == to }) else {
            return nil
        }
        
        let dx = landmark2.x - landmark1.x
        let dy = landmark2.y - landmark1.y
        return sqrt(dx * dx + dy * dy)
    }
    
    /// Pinch distance (thumb to index)
    var pinchDistance: CGFloat? {
        distance(from: "thumbTip", to: "indexTip")
    }
}

// MARK: - Gesture Events

/// High-level gesture events generated by the gesture engine
enum GestureEvent {
    case move(CGPoint)
    case mouseDown
    case mouseUp
    case click
    
    var description: String {
        switch self {
        case .move(let point):
            return "move(\(point.x), \(point.y))"
        case .mouseDown:
            return "mouseDown"
        case .mouseUp:
            return "mouseUp"
        case .click:
            return "click"
        }
    }
}

// MARK: - Gesture State

/// State machine states for gesture recognition
enum GestureState {
    case idle           // No hand detected
    case tracking       // Hand detected, cursor following
    case clutch         // Hand closed/hidden, cursor frozen
    case down           // Pinch detected, mouse pressed
    case drag           // Mouse down + movement
    
    var description: String {
        switch self {
        case .idle: return "idle"
        case .tracking: return "tracking"
        case .clutch: return "clutch"
        case .down: return "down"
        case .drag: return "drag"
        }
    }
}

// MARK: - Smoothed Point

/// A point with smoothing metadata
struct SmoothedPoint {
    let point: CGPoint
    let timestamp: CFTimeInterval
    let rawPoint: CGPoint
    
    var smoothingDelta: CGFloat {
        let dx = point.x - rawPoint.x
        let dy = point.y - rawPoint.y
        return sqrt(dx * dx + dy * dy)
    }
}
